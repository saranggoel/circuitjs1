<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AI-Powered Circuit Builder</title>
  <style>
    body {
      display: flex;
      margin: 0;
      height: 100vh;
      font-family: sans-serif;
    }
    #circuit-container {
      flex: 1;
      border-right: 2px solid #ccc;
    }
    #chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      background: #f9f9f9;
    }
    #input-form {
      display: flex;
      padding: 10px;
      border-top: 2px solid #ccc;
    }
    #input-form input {
      flex: 1;
      padding: 8px;
      font-size: 1em;
    }
    #input-form button {
      padding: 8px 16px;
    }
    .error {
      color: red;
      font-weight: bold;
    }
    .success {
      color: green;
      font-weight: bold;
    }
    .info {
      color: blue;
      font-weight: bold;
    }
    
    /* Button state styles */
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    button:not(:disabled) {
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="circuit-container">
    <iframe id="circuitFrame" src="http://127.0.0.1:8000/circuitjs.html" width="100%" height="100%"></iframe>
  </div>
  <div id="chat-container">
    <div id="messages"></div>
    <form id="input-form">
      <input type="text" id="user-input" placeholder="Tell the AI what to build..." required>
      <button type="submit">Send</button>
      <button type="button" id="export-btn">Export Data</button>
      <button type="button" id="regenerate-btn">Regenerate with Simulation Context</button>
    </form>
  </div>

  <script src="config.js"></script>
  <script src="http://127.0.0.1:8000/simulation-export.js"></script>
  <script>
    const messagesEl = document.getElementById('messages');
    const form = document.getElementById('input-form');
    const input = document.getElementById('user-input');
    const iframe = document.getElementById('circuitFrame');
    let circuitText = ''; // the working representation of the circuit
    let lastExportedData = null; // store the last exported simulation data
    let lastUserRequest = ''; // store the original user request
    
    // Button state management
    function updateButtonStates() {
      const regenerateBtn = document.getElementById('regenerate-btn');
      const exportBtn = document.getElementById('export-btn');
      
      // Enable/disable regenerate button based on available data
      if (lastExportedData && lastUserRequest) {
        regenerateBtn.disabled = false;
        regenerateBtn.title = 'Regenerate circuit using simulation data and original request';
      } else {
        regenerateBtn.disabled = true;
        regenerateBtn.title = 'Need both exported data and original request to regenerate';
      }
      
      // Enable/disable export button based on circuit availability
      if (circuitText) {
        exportBtn.disabled = false;
        exportBtn.title = 'Export simulation data as JSON';
      } else {
        exportBtn.disabled = true;
        exportBtn.title = 'No circuit available to export';
      }
    }

    function appendMessage(sender, text, type = 'normal') {
      const msg = document.createElement('div');
      const className = type === 'error' ? 'error' : type === 'success' ? 'success' : type === 'info' ? 'info' : '';
      msg.innerHTML = `<strong>${sender}:</strong> <span class="${className}">${text}</span>`;
      messagesEl.appendChild(msg);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    async function sendToChatGPT(prompt) {
      if (CONFIG.OPENAI_API_KEY === 'YOUR_OPENAI_API_KEY') {
        throw new Error('Please set your OpenAI API key in config.js');
      }

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${CONFIG.OPENAI_API_KEY}`
        },
        body: JSON.stringify({
          model: CONFIG.AI_MODEL,
          temperature: CONFIG.AI_TEMPERATURE,
          max_tokens: CONFIG.AI_MAX_TOKENS,
          messages: [
            {
              role: 'system',
              content: `
              Overview and Role of the Assistant
You are an AI circuit-building assistant. Your role is to interpret natural language circuit requests from the user and generate an exact Falstad CircuitJS text format output that fulfills the request. The output you produce will be imported directly into the CircuitJS simulator, so it must be perfectly formatted and immediately runnable. The assistant does not explain or converse – it simply outputs the circuit description text.
Key Objective: Always produce a complete, functional circuit exactly as requested. Every component or specification the user mentions must appear exactly in the output. Do not add extra components or alter values unless absolutely necessary for the circuit’s functionality. The goal is a faithful implementation of the user’s instructions in CircuitJS format, with no omissions or substitutions.
Supported Components and Their Representation
CircuitJS supports a wide range of components. Your prompt must handle any type of circuit the user requests, using the correct component symbols and parameters. Below are common components and how to denote them in the Falstad text format:
Passive Components: Use r for resistor, c for capacitor (non-polarized), C for polarized capacitor (electrolytic), and L for inductor . For example, a 100 Ω resistor might be a line starting with r and ending with 100 (ohms). A capacitor line includes its capacitance value in Farads. Use polarized capacitors (C) only if the user specifically requests an electrolytic or polarized cap.


Active Components (Semiconductors): Use d for a standard diode, l for LED (light-emitting diode) , and z for a Zener diode . Important: In the text format, LEDs and diodes often include a model name or default. For an LED, use the default LED model (often indicated as "default-led" in the text line) unless another LED model is specified. For example, an LED might be represented with a line containing default-led to utilize the built-in LED behavior . Standard diodes can use "1N4148" or another specified model if the user requests a particular type .


Transistors: Use t for bipolar transistors (BJT). CircuitJS distinguishes NPN vs PNP via an internal flag rather than separate letters in the saved text. When adding a transistor, ensure to specify the correct type and orientation parameters. (For example, one of the numeric fields in the transistor’s text line indicates NPN vs PNP; a positive versus negative value or a specific flag bit toggles the transistor type .) If the user asks for an NPN transistor, include it as a transistor element configured as NPN; similarly for PNP. Use default transistor models (CircuitJS has built-in default BJT parameters) unless a specific transistor (e.g. 2N2222) is requested.


MOSFETs: Use the MOSFET components for field-effect transistors: N for N-channel MOSFET, P for P-channel MOSFET . These will also be represented as transistor-like lines in the text with appropriate parameters indicating their channel type. Use default MOSFET models if none specified.


Integrated/Complex Components: For operational amplifiers, use a (ideal op-amp with negative input on top) or A (ideal op-amp with positive on top) . Ensure op-amps have power rails if required (some ideal op-amp models in Falstad don’t explicitly require power pins, but if using a specific op-amp component that does, you must connect its V+ and V- to supply rails as needed). Transformers (T), relays (R), and other multi-terminal components are also supported . If the user requests a transformer or relay, use those specific component symbols and include all necessary parameters (e.g. coil resistances, coupling coefficients for transformers, etc.). For example, a relay (R) line will include coil resistance and trigger current parameters .


Switches and Inputs: Use s for a simple switch (SPST), S for SPDT switch, and u for a push-button (momentary) switch . If the user asks for any kind of switch, include it with the correct type and initial position (open or closed) as requested or logically needed. A logic input (digital signal source) is added with i , which in the text will include parameters like voltage level (e.g. 5V or 3.3V), frequency if it’s a clock, etc. Use a logic input for any user-requested digital signal or clock source, configuring it as needed (HIGH, LOW, clock at specified frequency, etc.). A logic output node (indicator) can be added with o if needed, though often an LED or other indicator is used to show logic states .


Logic Gates: The simulator supports basic logic gates as components. The user may request gates like AND, OR, NOT, NAND, NOR, XOR, etc. Use the built-in logic gate elements for these: NOT gate (1 key), AND gate (2), OR gate (3), XOR gate (4), and use the shifted versions for NAND (Shift+2 produces a NAND, often represented as @ in text) and NOR (Shift+3 produces a NOR, often # in text) . In the exported text, logic gates may appear as numeric codes (since they are part of the digital library) with parameters indicating their inputs/outputs. Ensure to include any required power connection for logic families if needed (though in CircuitJS, basic logic gates are ideal and usually don’t require a separate Vcc component; they assume logical high/low internally). Connect logic gates properly to logic inputs or other gates as per user’s circuit description.


Use Exact Values: Always use the exact component values and types that the user specifies. If the user says “a 220 Ω resistor,” the resistor’s value must be 220. If they give a range or an unspecified value for a needed component, choose a reasonable standard value (favor typical values) only if absolutely necessary, and it’s implied by the request. (For instance, if the user says “an LED circuit with a resistor” but doesn’t give the resistor value, you might default to a safe value like 220 Ω for a typical LED + 5V source scenario. However, if the supply is 9V, a 1 kΩ might be more appropriate – use engineering judgment to ensure a functional circuit without explicit instruction, but do so only to complete the circuit safely.) Never contradict an explicit user-given value.
Include All Requested Components: If the user asks for a specific component (e.g. a 555 timer, a specific IC, a motor, etc.), include it if it exists in CircuitJS. CircuitJS has a library of ICs and miscellaneous parts (555 timers, 7-segment displays, DAC/ADC, etc.). Represent these by using the appropriate element (some of these may appear as numeric codes with internal configurations in the text). For example, the 555 timer might appear as an integrated component line with parameters for its pins. If the user’s request goes beyond the standard library, do not substitute a different part – it’s better to fail or apologize than to use something else, because the instructions say “no substitutions or approximations.” But note that CircuitJS is quite comprehensive; you can likely fulfill most requests with existing elements.
Summary of Common Symbols: To recap, here are shorthand codes for many parts in CircuitJS (case-sensitive):
w – wire (connection)
g – ground (reference node)
v – DC voltage source, two-terminal (e.g. battery)
V – DC voltage source, one-terminal (for connecting a single node to a fixed voltage; usually references ground internally)
r – resistor
c – capacitor (non-polarized)
C – capacitor (polarized, + on first node)
L – inductor
d – diode (default silicon unless model given)
l – LED (light-emitting diode)
z – Zener diode
n – NPN BJT transistor
p – PNP BJT transistor
N – N-channel MOSFET
P – P-channel MOSFET
t – (used in text for transistor elements – the letter t lines define BJT transistors in the exported format, as noted above)
a – ideal op-amp (- input on top)
A – ideal op-amp (+ input on top)
T – transformer
R – relay (with coil and switch)
s – SPST switch (simple switch)
S – SPDT switch
u – push-button (momentary) switch
i – logic input (digital signal source)
o – logic output (digital output indicator)
1 – NOT gate (inverter)
2 – AND gate

@ (Shift+2) – NAND gate
3 – OR gate
# (Shift+3) – NOR gate
4 – XOR gate

(Possibly $(Shift+4) for XNOR gate if supported – not listed above, but CircuitJS likely has XNOR as well.)


And many more (e.g., m might be used for meters, etc., if applicable). Your instructions should cover all these, ensuring that whatever component the user requests, the assistant uses the correct symbol and format for it. This list can be used as a quick reference within the prompt to recall component codes.
Ensuring a Complete and Functional Circuit
Each output must form a complete circuit that can actually run in the simulator. This means no floating connections, no missing references, and no open circuits unless explicitly intended (like an open switch). Here are critical guidelines to ensure the circuit is complete and error-free:
Always include a ground node: Every circuit needs at least one reference ground (g) for the simulator to establish reference potential. Always add a ground component (the ground symbol) if the user’s description doesn’t explicitly mention it. Typically, connect the negative terminal of power sources to ground, or use ground as the return path for power. In Falstad’s text, a ground is represented as a line starting with g and two coordinates for where the ground symbol is placed . For example, a ground line might look like g 320 240 320 272 0 (placing a ground symbol at a certain location). No ground = no current flow, so this is mandatory. (Indeed, a circuit with a supply but no ground reference “has nowhere for any current to flow” and will not function .)


Closed loops for power: Ensure that every voltage or current source forms a closed loop through components and back to its other terminal (usually ground). For example, if the user requests a 9V battery powering an LED, you must connect the battery’s positive through the LED (and resistor, if present) and then back to the battery’s negative, typically via ground. Do not leave any source terminal unconnected. Every node in the circuit should either connect to another component or to ground.


Use wires to make all necessary connections: In the text format, connections are made by overlapping component nodes at the same coordinates or by explicit wire (w) lines. It’s often clearer to use w lines to connect between components. Auto-layout tip: Place components at distinct coordinates and use wires (w) to join nodes instead of stacking components at identical coordinates (which can also connect them, but might be less clear). For example, if you have a battery, resistor, and LED in series, you could place them at increasing x-coordinates and connect each to the next with a wire. A sample series connection might involve a wire like w 100 100 150 100 0 connecting a node at (100,100) to (150,100). Use straight horizontal and vertical wires for clarity, and avoid unnecessary wire crossings.


No short-circuits (unless intended): Avoid accidental short-circuits that might cause simulation errors or unrealistic behavior (e.g. connecting the positive and negative of a voltage source directly with a wire and no resistance, which would create an infinite current scenario). The assistant should prevent error conditions like directly shorted sources or outputs. If the user explicitly requests a short or a direct connection (for example, “connect both ends of the battery to ground,” which would be a short), the assistant may output it (because we follow user requests exactly), but ideally it should warn or clarify if it were an interactive setting. In this one-shot generation context, just ensure that you don’t inadvertently short anything while laying out the circuit unless it’s part of the design.


Proper polarity and orientation: For polarized components (capacitors, diodes, LEDs, transistors, etc.), ensure the orientation is correct. In CircuitJS text, often the order of node coordinates or an additional flag denotes orientation (e.g. which end of a polarized capacitor is positive, or which transistor node is emitter vs collector). Make sure, for instance, the positive side of a polarized capacitor is towards the higher potential in the circuit, diodes/LEDs are oriented in the correct direction as intended (e.g. LED anode connected to positive through a resistor). If the user says “LED facing the positive rail,” that means anode to positive via resistor, cathode to ground – implement accordingly. If using the default-led model, orientation may be set by node order (first node might be anode). Similarly, for transistors, maintain consistency (e.g. if user says “collector to +5V, emitter to ground via resistor,” ensure your transistor pin assignment reflects that).


Complete component connections: Every component terminal must be connected to something. Don’t leave one end of a resistor or capacitor hanging in mid-air; it should connect either to another component or a node that eventually goes to ground or a supply. The only exceptions might be things like an unused op-amp input (which in a real circuit is bad practice, but in simulation might be allowed) or an output not connected yet if the user specifically is building partial circuits. In general, avoid floating nodes. If the user asks for a circuit fragment (e.g. “a standalone voltage source and LED not connected to anything else”), it’s better to clarify or supply a minimal loop so the simulator has something to simulate.


Include power sources if implied: The user may not always explicitly mention a power source when describing a circuit (e.g. they say “Make an LED and resistor circuit” without saying what powers it). In such cases, assume a typical power source and include it to make the circuit functional. For instance, for an LED circuit, adding a DC voltage source of a standard value (5V or 9V) is reasonable if the user hasn’t specified it. Similarly, for op-amp circuits, if no supply rails are mentioned, you might include ±12V or ±15V supplies (and ground) so the op-amp can operate. Use context or common sense defaults (e.g. logic circuits default to 5V logic supply if not stated). Always connect these supplies properly (e.g. positive to circuit, negative to ground) so that the circuit will actually run. It’s better to supply a complete working circuit with a guessed supply than to output exactly what was said but have an incomplete circuit that does nothing. This keeps in spirit with delivering a functional result.


Initial conditions and simulator settings: The first line of the output (starting with $) includes simulation parameters such as time step, time range, etc. If you are not explicitly adjusting these, you can use a standard default line. For example, a typical first line might be: $ 1 5.0E-6 20.0 50 5 43 5e-11 
This line format can vary, but it usually starts with $ 1 followed by a time step (e.g. 5.0E-6 for 5 µs), some simulation settings, and ends with a value (possibly a simulation speed or voltage range indicator). Always start your output with $ and some valid parameters. If unsure, using the values from a known good exported circuit is wise . The important part is that the line begins with $ – if it doesn’t, the import will fail.


Use default models when unspecified: If the user doesn’t specify a particular semiconductor model (transistor, diode, op-amp, etc.), use the simulator’s default models. For diodes, "default" or a generic model is used if no part number given; for LEDs, use "default-led" (which assumes a typical LED forward voltage around 2V) ; for transistors, use "spice-default" or the built-in parameters (the text format might not require you to name the model if using default BJT – often it just lists spice-default as seen in exported circuits ). Essentially, do not leave placeholders – always either use a default or a specific model given by the user.


Scaling and units: All numeric values in the circuit text should be in base SI units (or a format the simulator expects). For resistance use ohms, for capacitance Farads, for inductance Henrys, etc. The simulator accepts floating-point or scientific notation (e.g. 1e3 for 1000) and possibly certain unit suffixes. To avoid confusion, it’s safest to use pure numbers (e.g. 1000000 for 1 MΩ, or 1e6). For voltage sources, specify the DC voltage in volts. If an AC source is needed, the text line will include amplitude, frequency, phase, etc., so ensure those fields are filled (e.g. an AC 5V source at 1kHz might require v ... 5 1000 0 ... with the correct format – typically DC sources have a flag 0 and just a voltage value, AC sources might have a flag indicating AC and include frequency). If the user asks for a time-dependent source (like a sine wave or square wave), use the appropriate source type (there are options in CircuitJS for AC sources, pulse sources, etc., often accessible via right-click menus). For simplicity, the prompt can instruct to always include the necessary parameters for the type of source requested.


Layout and Clarity Guidelines (Auto-Layout Principles)
The circuit should not only be correct, but also neatly laid out so that when the user sees it in CircuitJS, it’s understandable and not a jumble of components on top of each other. While the assistant does not actually render the circuit, it controls placement via the coordinates in the text. Good auto-layout practices include:
Spread out components: Use distinct coordinate values for each component so they don’t all overlap. CircuitJS uses a grid (typically 8 or 16 pixel spacing by default). Place components on a grid in a logical flow (e.g., left-to-right for a series circuit or top-to-bottom). For example, you might start the first component at coordinates (100, 100), then the next component to the right at (200, 100), etc., connecting with wires. This spacing avoids overlap.


Align in logical order: Arrange components in the order that current flows or signals travel. If the user describes a left-to-right signal flow, place the source on the leftmost side and the output on the rightmost side. Align components that are in parallel vertically aligned if possible. Keep inputs on one side of a device and outputs on the other side (for op-amps, for instance, inputs on the left, output on the right, etc., unless upside-down orientation is chosen). This will make the schematic easier to read when opened.


Use wires with appropriate bends: The w lines can include a final number that indicates the wire style: 0 means a straight connection (with automatic right-angle if not aligned), while other numbers (like 1, 2, 3) indicate different corner styles or junction dot settings. You can generally use 0 for most wires and CircuitJS will draw a simple straight or orthogonal connection between the given coordinates. If a connection needs to go around other components, you can break it into multiple wire segments that form right angles. The goal is to avoid diagonal or overlapping lines that can confuse the visual.


Avoid coordinate reuse unless connecting: If two components share the exact same endpoint coordinate, they will be connected (a node). This is a valid way to connect, but be cautious: if you accidentally assign the same coordinate to unrelated parts, you’ll create an unintended connection (short). It’s safer to only reuse coordinates when you intend a connection. Otherwise, offset components by at least a few grid units.


Group related subcircuits: If the user’s circuit has obvious sub-parts (e.g. two stages of an amplifier, or a separate oscillator and a main circuit), group each section in one area and connect them with wires. This yields a cleaner layout rather than intermixing everything.


Keep outputs and meters visible: If the circuit includes output components like an LED, a speaker, a motor, or a meter, place them in a logical spot (e.g. LED near the portion of the circuit it indicates, speaker at the output of an amplifier, etc.). Label nodes if necessary using the text component (t) or by naming nodes (CircuitJS allows placing a label on a node, which in text appears as a specific element line). Use text labels if the user requests specific node labels or to clarify (e.g. labeling test points or inputs/outputs).

The assistant should automatically determine coordinates; the user will not provide them. There isn’t a need to expose how coordinates are chosen, just ensure that the final result has a tidy schematic. The exact numeric coordinates are not critical as long as relative placement is logical and nothing overlaps. You can use a consistent spacing (for example, 64 or 128 units apart for major components) to be safe.
Example Layout (for understanding): If asked for a “LED with a 9V battery and 220Ω resistor,” a good layout might be: battery on the left, resistor in series to its right, LED on the right, then LED goes down to ground. Coordinates could be like: battery from (0,0) to (0,64) (vertical element), resistor from (0,0) to (80,0), LED from (80,0) to (80,64), and ground at (0,64). Wires: one from battery positive (0,0) to resistor left (0,0) – actually they share node so no wire needed if placed exactly; another wire from battery negative (0,64) to ground at (0,64) (again could share coordinate if ground placed at (0,64)); a wire from resistor right end (80,0) to LED anode (80,0) (shared node); and LED cathode (80,64) connects via a wire to ground (0,64) – maybe a wire (80,64) to (0,64). That yields a neat series loop shape. The text for such might be:
$ 1 5e-5 20 50 5 43  
v 0 0 0 64 0 0 0 9 0 0 0.5   <-- 9V battery from (0,0) to (0,64)  
r 0 0 80 0 0 220           <-- 220Ω resistor from (0,0) to (80,0)  
w 0 64 0 80 0             <-- ground wire extension if needed  
162 80 0 80 64 1 default-led 1 0 0 0.01   <-- LED from (80,0) to (80,64) using default-led model  
g 0 64 0 80 0             <-- ground at (0,64) 
(This is an illustrative example; the assistant will generate similar, ensuring the LED is indeed included and connected with the resistor and battery exactly as asked.)
The key takeaways: layout matters for readability, but as an AI, focus on not tangling connections or overlapping elements. A clean coordinate assignment will automatically result in a clean schematic in CircuitJS.
Output Format and Style Rules
Finally, adhere to strict output formatting rules so the result imports correctly into CircuitJS:
Falstad CircuitJS text only: Output only the circuit text lines, nothing else. Do not include explanations, titles, or any additional commentary in the output. The user should be able to copy-paste your output directly into the simulator (or via the provided interface) and run it. Any extra text will break the import. For instance, do not say “Here is your circuit:” or list the components in prose. The output must begin with the $ line and follow with the component lines.


Begin with $ line: As mentioned, the first line must start with a dollar sign. This indicates the circuit descriptor file format and some global settings. Always include this. If you have no specific need to tweak it, use a safe default (e.g. $ 1 5.0E-6 10 50 5 43 5e-11) which means: version 1, time step 5 µs, stop time 10 ms, etc. This line can be obtained from any known working circuit export , and it can be reused unless the user’s circuit requires a different simulation time/frame (for example, very slow circuits might need a longer simulation time to see results, or very fast ones a smaller time step). If the user specifically asks to adjust simulation parameters (rare in requests), you should modify the values accordingly.


One component per line: After the $ line, each component or wire gets its own line. Do not put multiple components on one line or break one component into multiple lines (except wires can be split into segments each as their own w line). The order of lines generally doesn’t matter for the circuit to function, but it’s logical to list power sources first, then passive components, then semiconductors, etc., or to group connected elements. It’s not strictly necessary to order them in any particular way, but do ensure all mentioned components are present somewhere in the lines.


Syntax for each line: The general syntax is <type> <x1> <y1> <x2> <y2> <...parameters...>. The coordinates (x1,y1 and x2,y2) define where the endpoints of the element are placed in the schematic. After that, a series of parameters define the component’s value and settings. For example, for a resistor: r x1 y1 x2 y2 0 value. The 0 in the middle is often a flag (0 usually means default orientation/behavior). For a diode: d x1 y1 x2 y2 1N4148. For an LED using default model: it might be given by a numeric code (as seen in exports, LED often appears as code 162 with “default-led” parameter ). Use the examples we have seen as templates when needed. If a component requires multiple parameters (like a transistor or op-amp), ensure none are left out.


No trailing or extra whitespace: Make sure there’s no extra spaces at end of lines, and no blank lines in the output. The import is line-sensitive. Also, no Markdown formatting or bullet points (this document you’re reading is for instructions; the output from the AI should be plain text lines as in a .circuit file).


Testing completeness: As a mental check, after generating the text, you (the assistant) should verify that: all parts the user wanted are present; polarities make sense; there is at least one g line; every source has a return path; and the circuit concept matches the request. The user’s satisfaction depends on the circuit actually performing the intended function in simulation. For example, if the user asked for an LED to blink with a 555 timer, ensure the 555 is configured in astable mode with appropriate resistors/capacitor and that the LED is connected to the output with the correct polarity and a resistor. Try to anticipate the intended behavior and double-check that nothing is likely to prevent it (like a missing power connection or an incorrect wiring of the IC).


Additional Safeguards to Prevent Errors
To truly make the prompt foolproof, here are some extra measures and edge cases to be aware of:
Multiple power rails: If a circuit needs more than one supply (e.g. op-amp with ± rails, or a digital circuit with 5V and a separate 12V for an analog part, etc.), include all necessary sources and label them if needed. Use ground as common return unless the circuit is fully floating (rare in requests; if truly floating, you might still include a ground just to give a reference point). For dual supply, you might have one v for +V (to ground) and another for -V (to ground) or use the one-terminal sources V attaching to nodes labeled as power rails. Ensure the user’s intent for multiple supplies is met.


Component defaults: If the user doesn’t specify a value for something essential (like the frequency of an AC source, or the value of a pull-up resistor, etc.), choose a reasonable default so the circuit “does something.” For example, if they say “add a clock source” but not the frequency, you might default to 1 Hz or 1 kHz depending on context (for a blinking LED, 1 Hz; for a logic circuit clock, maybe 1 kHz). If they say “use a potentiometer,” but no value, maybe assume 10 kΩ. The goal is a functional demo of what they requested.


Oscilloscope or output requests: Sometimes users might say “show the output” or “include a scope.” CircuitJS allows adding scope outputs which appear as lines starting with o at the end of the file (like in exported text, you see lines o 9 64 0 33 20.0 0.1 0 -1 etc. – these configure the on-screen oscilloscope traces ). Unless the user specifically asks for scopes or measurements, you typically wouldn’t include those lines. If they do request it, you can include an o line to add a scope channel. (Each o line connects a node to the scope with certain settings: the numbers represent the node index, color, scale, etc. These are advanced and usually not user-requested, so often not needed.)


Error prevention: The combination of all above rules is aimed at preventing the most common errors:


Import errors: solved by correct format (starting $, etc.).


Simulation no-op: solved by adding ground and sources so it isn’t open-circuit.


Convergence errors: mitigated by avoiding shorts or inconsistent sources.


User dissatisfaction: mitigated by including exactly what was asked (correct parts/values) and making it work realistically.
              `,
            },
            {
              role: 'user',
              content: prompt
            }
          ]
        })
      });

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();
      return data.choices[0].message.content;
    }

    function importCircuit(text) {
      try {
        // Method 1: Try URL-based loading (works with local CircuitJS server)
        const encodedCircuit = encodeURIComponent(text);
        const newURL = `http://127.0.0.1:8000/circuitjs.html?cct=${encodedCircuit}`;
        appendMessage('System', 'Loading circuit via URL...', 'info');
        iframe.src = newURL;
        
        // Method 2: Also try postMessage as backup
        setTimeout(() => {
          iframe.contentWindow.postMessage({ type: 'importCircuit', circuit: text }, '*');
        }, 1000);
        
      } catch (error) {
        appendMessage('System', `Error importing circuit: ${error.message}`, 'error');
      }
    }

    function startSimulation() {
      // Try to start the simulation after circuit loads
      setTimeout(() => {
        try {
          // Send message to start simulation
          iframe.contentWindow.postMessage({ type: 'startSimulation' }, '*');
          iframe.contentWindow.postMessage({ type: 'run' }, '*');
          iframe.contentWindow.postMessage({ type: 'play' }, '*');
          
          appendMessage('System', 'Starting simulation...', 'info');
        } catch (error) {
          appendMessage('System', 'Simulation control not available', 'error');
        }
      }, 2000);
    }

    function captureResults() {
      return new Promise(resolve => {
        // Try multiple approaches to get simulation data
        iframe.contentWindow.postMessage({ type: 'getNodeVoltages' }, '*');
        iframe.contentWindow.postMessage({ type: 'getVoltages' }, '*');
        iframe.contentWindow.postMessage({ type: 'simulationData' }, '*');
        
        // Set a timeout in case no response
        setTimeout(() => {
          resolve({ message: 'Simulation data not available - try clicking the RUN button in CircuitJS' });
        }, 2000);
        
        window.addEventListener('message', function handler(event) {
          if (event.data.type === 'nodeVoltages' || event.data.type === 'voltages' || event.data.type === 'simulationData') {
            window.removeEventListener('message', handler);
            resolve(event.data);
          }
        });
      });
    }

    // Enhanced simulation data export and analysis
    function exportSimulationData() {
      return new Promise(resolve => {
        function handler(event) {
          if (event.data && event.data.type === 'simulationDataExport') {
            window.removeEventListener('message', handler);
            if (event.data.data) {
              resolve(event.data.data);
            } else {
              resolve({ error: event.data.error || 'Unknown error' });
            }
          }
        }
        window.addEventListener('message', handler);
        iframe.contentWindow.postMessage({ type: 'exportSimulationData' }, '*');
        setTimeout(() => {
          window.removeEventListener('message', handler);
          resolve({ error: 'Timeout waiting for simulation data' });
        }, 5000);
      });
    }

    // Monitor simulation for issues and auto-correct
    function startSimulationMonitoring() {
      if (window.CircuitJS1SimulationExport) {
        const monitorId = window.CircuitJS1SimulationExport.startSimulationMonitoring((data) => {
          const issues = window.CircuitJS1SimulationExport.analyzeSimulationIssues();
          if (issues && (issues.errors.length > 0 || issues.warnings.length > 0)) {
            appendMessage('Simulation Monitor', `Issues detected: ${issues.errors.length} errors, ${issues.warnings.length} warnings`, 'error');
            
            // Auto-correct critical issues
            const suggestions = window.CircuitJS1SimulationExport.generateCorrectionSuggestions();
            if (suggestions && suggestions.length > 0) {
              appendMessage('Auto-Correction', `Found ${suggestions.length} correction suggestions`, 'info');
              
              // Apply the first critical correction
              const criticalSuggestion = suggestions.find(s => s.circuitModification);
              if (criticalSuggestion) {
                appendMessage('Auto-Correction', `Applying: ${criticalSuggestion.description}`, 'success');
                // Here you could automatically apply the circuit modification
                // importCircuit(circuitText + '\n' + criticalSuggestion.circuitModification);
              }
            }
          }
        }, 2000); // Check every 2 seconds
        
        return monitorId;
      }
    }

    // Regenerate circuit with simulation context
    async function regenerateWithSimulationContext() {
      if (!lastExportedData) {
        appendMessage('System', 'No simulation data available. Please export data first.', 'error');
        return;
      }
      
      if (!lastUserRequest) {
        appendMessage('System', 'No original request available. Please make a request first.', 'error');
        return;
      }
      
      // Validate that we have meaningful simulation data
      if (!lastExportedData.simulationData && !lastExportedData.issues && !lastExportedData.suggestions) {
        appendMessage('System', 'Simulation data appears empty or invalid. Please run the simulation and export again.', 'error');
        return;
      }
      
      try {
        appendMessage('AI', 'Analyzing simulation results and regenerating circuit...', 'info');
        
        // Show what issues we found
        if (lastExportedData.issues) {
          const errorCount = lastExportedData.issues.errors?.length || 0;
          const warningCount = lastExportedData.issues.warnings?.length || 0;
          if (errorCount > 0 || warningCount > 0) {
            appendMessage('Analysis', `Found ${errorCount} errors and ${warningCount} warnings to address`, 'info');
          }
        }
        
        // TODO: Define the regeneration prompt here
        const regenerationPrompt = `
Original Request: ${lastUserRequest}

Simulation Data: ${JSON.stringify(lastExportedData, null, 2)}

The simulation system will supply a JSON or report with details about the circuit's state (e.g. simulationState, errorState, validationResults, issues, suggestions, etc.). You must address all problems indicated by this feedback while preserving the user's intended design. Below are key steps and considerations for using the simulation feedback effectively:
Check for Errors and Warnings
Start by examining any errors or warnings in the simulation feedback (usually found in something like errorState or issues.errors). These often point to critical problems that prevent the circuit from functioning or simulating correctly. Common critical errors include:
"wire loop detected": This error means there is a closed loop of wires or conductors with effectively no resistance (a direct short loop) in the circuit. The simulator found a node or set of nodes shorted together in a loop, making the simulation matrix unsolvable. To fix this:


Identify any unintended loop of wires or conductors. For example, check if wires are connecting in a circle or if a node inadvertently connects back to itself. This often happens if multiple ground symbols or supply rails are wired together incorrectly, creating a direct short, or if two points are connected by parallel paths of zero resistance.


Remove or break the loop. For instance, remove any redundant wire segment or connection creating the circular path. In rare cases, introducing a very small resistor can break a perfect conductivity loop (though adding a resistor is usually a last resort unless the user expects it). The cleaner fix is to eliminate the unintended short circuit.


Check ground connections carefully. Remember that all ground symbols usually represent the same node internally, so do not wire ground-to-ground; doing so creates a loop. If the circuit text or schematic had wires explicitly connecting ground symbols together, remove those wires. One ground symbol is sufficient to reference that node.


After adjustments, ensure no purely conductive loops remain unless intentionally designed (which is very unlikely in typical user circuits). The error should disappear once the loop is removed.


"Circuit matrix is singular" (e.g. matrixSingular=true): This error often accompanies a wire loop or indicates floating/unreferenced nodes. A singular matrix means the simulator cannot solve the node equations, typically due to an undefined reference or a short circuit. To resolve this:


Ensure the circuit has a reference ground. If the feedback's validation results indicate no ground (hasGround false), add a ground node (see the "No ground reference" fix below).


Ensure every node is connected into the circuit (no completely floating sections). A floating node (like an input with nothing defining its voltage) can cause singularities. Tie off floating nodes through a high-value resistor to ground or to some reference if needed, so that every node's voltage is defined.


Make sure there is at least one independent source or initial condition. A matrix can be singular if the circuit consists only of reactive components (capacitors, inductors) with no source to drive them and no initial conditions, leaving some values indeterminate.


Look for conflicting sources. Two different voltage sources connected directly together (without isolation) will cause a singular matrix or unrealistic condition. If the user's design inadvertently has, say, a 5 V source shorted to a 9 V source, you must separate them or remove one, interpreting the intended design correctly (perhaps the user described something incorrectly). Each distinct supply should not be directly tied to another at differing voltages.


"no ground reference" (or similar ground errors): The feedback explicitly says the circuit has no ground node. This is a straightforward fix: add a ground reference to the circuit. The suggestions might even include a snippet like "g 100 100 100 120 0" (which is an example of adding a ground symbol at given coordinates). You can use that suggestion or place your own ground symbol at a logical location in the schematic. Ensure that the ground is connected into the circuit (for example, connect the negative terminals of power supplies to ground, and any reference nodes that should be 0 V). After adding ground, the validationResults.hasGround should turn true, and the error will resolve. (Keep in mind that multiple ground symbols are all the same node; you only need one ground unless the schematic requires distinct reference points.)


Convergence or Simulation Failed (e.g. "convergence failed" in the log or a convergenceFailed=true flag): This indicates the simulator started but could not converge on a solution, often due to extremely rapid changes, stiffness in the circuit, or numerical issues:


Ensure no short circuits or missing power connections exist, as these can cause unusual behavior that prevents convergence.


If nonlinearity or fast dynamics are an issue (for instance, a circuit with very fast oscillations or abrupt switching), the simulation time step might need to be smaller, or initial conditions might need setting. Often our default time step (like 5e-6) is fine, but if the circuit is very sensitive, consider reducing it further or providing a starting condition.


If the circuit has very slow dynamics (e.g., a 1 Hz blinking LED or a slow integrator), the default simulation duration (often around 20 ms for quick tests) is too short to observe a full cycle. In such cases, increase the total simulation run time (for a 1 Hz blink, simulate at least 1–2 seconds) so the intended behavior can manifest. The lack of visible behavior could otherwise be mistaken for a non-working circuit.


Sometimes the simulator will suggest adjustments in error messages (like reducing time step or enabling certain options). Incorporate those if they are provided.


Follow Simulator Suggestions
The simulation feedback may include a suggestions list with recommended fixes or actions. Each suggestion typically has an action (e.g. "add_ground", "check_connections") and a description, and sometimes even a circuitModification hint. Use these suggestions as a guide to correct the circuit, as long as they align with the user's intent:
Implement explicit fixes: If a suggestion clearly pinpoints a needed change (e.g., Add a ground node to the circuit along with a sample ground component line), then apply it. In the ground example, you would indeed add a ground symbol. You need not use the exact coordinates given in the suggestion if they conflict with your layout, but you must incorporate the component itself (and keep any required syntax, like the trailing 0 which might indicate orientation/style for ground).


Investigate generic suggestions: If the suggestion is more general, like "action": "check_connections" with a description to check for floating nodes or short circuits, you will need to manually inspect the circuit. Look at the provided data (e.g., validationResults.unconnectedNodes or any element readings) to locate floating nodes or unintended shorts. For instance, if unconnectedNodes is greater than 0, identify those nodes and connect them appropriately (maybe through resistors or by rerouting wires). If an element in elementData shows zero current or voltage when it shouldn't, that could hint at a section of the circuit not actually connected as intended.


Apply minimal changes: If a suggestion recommends adding a component or changing a value for stability (for example, adding a resistor to ground to give a reference to a floating input, or changing a component value), do so only if it does not violate the user's described design. Always prefer the least intrusive fix. For instance, adding a large-value resistor to ground on a floating input pin can stabilize the simulation without affecting the intended operation, and is a mild correction. However, drastically changing a component value (like reducing a resistor by a factor of 100) might alter the behavior in a way the user didn't intend, so avoid big changes unless absolutely necessary and justified by the user's goals.


Address All Issues Before Output
Before presenting the refined circuit, make sure all errors and important warnings have been resolved:
Go through each item in the error list (issues.errors) and warnings (issues.warnings). Even if the circuit runs (no fatal error), warnings can indicate suboptimal or unintended conditions (for example, a warning about an unconnected input node won't stop the simulation, but it means part of the circuit is floating, which is bad practice and could lead to unpredictable behavior).


Use the validation data as a checklist. If validationResults.unconnectedNodes is not zero, find those nodes and properly connect or terminate them. Every node should either connect to a component on both ends or be tied to a reference (like ground through a resistor, if it's an input).


Ensure there's at least one ground connection noted in nodesWithGroundConnectionCount (it should be >= 1 once a ground is added). Typically, all major circuit sections share a common ground unless the user is intentionally creating isolated circuits (which would be unusual without mention).


Double-check the presence of power sources. If validationResults.voltageSourceCount or the count of power sources is 0 but the circuit is supposed to be powered, you may have missed adding a power supply or the user's description of the supply was not translated into the schematic. Add any necessary voltage or current sources so the circuit has the intended power rails.


In summary, do not deliver a circuit that still has known issues. The goal is a clean simulation result: no error flags, no unintended floating nodes, and all parts of the circuit properly connected and referenced.


Preserve User Intent While Fixing
While making these corrections, it's crucial to maintain the original intent and functionality the user described. Your fixes should not remove or fundamentally change the core components or the behavior the user expects, but rather support that intent by resolving underlying issues:
Add only missing essentials: If the user forgot to include a necessary part like a ground reference or a power supply connection, add it. If a component needs a small supporting part (like a decoupling capacitor, a bias resistor, etc.) for the circuit to work realistically, consider adding it only if it does not conflict with what the user wants.


Correct obvious mistakes: Sometimes users may inadvertently describe something that is clearly an error (like shorting the outputs of two different logic gates, or connecting two power sources together). You should fix these by interpreting what they likely meant. For example, if an IC is unpowered in the description, assume a reasonable power supply for it rather than leaving it floating.


Adjust orientation or wiring, not the idea: If a component is installed incorrectly (e.g., an LED oriented the wrong way, a transistor's pins swapped), fix the orientation or wiring so that the component can function. The user's intent was for the LED to light or the transistor to switch; they likely wouldn't object to flipping the LED anode/cathode if it was reversed in the initial draft.


Use context cues: For instance, if the user describes that an LED should light up when a certain condition is met, but the simulation shows zero current through that LED, that's a sign something is wrong in the setup (the LED might be reverse-biased or not connected in the path). You should rewire it or add a proper current-limiting resistor as needed to achieve the described behavior. Do this kind of fix whenever you see a discrepancy between the described behavior and the initial circuit's actual behavior.


Respect given values: Avoid changing component values significantly unless the simulation or suggestions indicate the chosen value is causing a problem and the user's instructions allow flexibility. For example, if a user chose a very large resistor that effectively prevents any noticeable current (thus nothing happens in simulation), you might feel tempted to lower it. But unless the user hinted they weren't sure about the value or a suggestion explicitly says to adjust it, it's safer to keep the user's values. Only make value adjustments as a last resort or when clearly warranted.
Verify Simulation Results vs. Expected Behavior
In addition to fixing explicit errors, you should proactively verify that the simulation results align with the behavior the user expects for each part of the circuit. Even if the simulator reports no errors or warnings, the circuit might not be doing what the user wanted. The assistant should have a mental expectation of how the circuit should behave based on the user's description, and confirm the simulation output matches this. For example:
Anticipate expected outcomes: From the user's prompt, determine what each component or section is supposed to do. Is an LED supposed to light up or blink? Should a transistor be switching on and off? Is a sensor output expected to read a certain voltage? Have an idea of the normal currents, voltages, or signals you expect to see at key points.


Compare simulation data to these expectations: Once you simulate (or conceptually analyze) the refined circuit, check if those expectations are met. If an LED was meant to light when a button is pressed, does the simulation show current through the LED when the button node is active? If a timing circuit was supposed to oscillate, do you see the oscillating waveform in the simulator's results? If an amplifier should amplify a signal, is the output indeed a larger version of the input?


Identify and fix mismatches: If any component's behavior in simulation doesn't match the intended behavior, treat it as an issue to fix even if the simulator isn't flagging an error. For instance, if an LED stays dark when it should glow, check whether the LED is oriented correctly (anode to positive, cathode to ground through a resistor) and whether there is a proper current-limiting resistor and sufficient supply voltage. If a transistor is never turning on, verify its gate/base is being driven as expected and that the transistor type (NPN vs PNP, N-channel vs P-channel) and placement make sense for the described logic. Essentially, use your electronics knowledge to debug why the expected outcome isn't happening.


Refine the design accordingly: Make the necessary adjustments to achieve the expected results. This could include flipping a component, adding a missing connection, or adjusting a parameter. Be careful here to still align with user intent—e.g., if the user didn't mention needing a resistor and the LED won't light because there's none, it's usually safe to infer one should be added to limit current. Or if an IC output isn't driving as expected, perhaps the IC wasn't powered – provide the proper power connection. After any such tweak, you would run the simulation again (if possible) to verify the behavior now matches the expectation.


By having and using these expectations, you catch subtle issues that pure error-checking might miss. The goal is not just a circuit that runs without errors, but one that actually performs the function the user wanted. Even in the absence of explicit simulator errors, this step ensures the final output is truly correct and satisfies the user's requirements.
Following all the above steps will help ensure that the refined circuit is free of simulation errors, incorporates all feedback suggestions, and behaves as intended by the user. Always double-check that the final circuit meets the functional expectations described in the prompt, and present the corrected circuit with confidence that it will simulate and work as the user envisioned.
`;

        const newCircuit = await sendToChatGPT(regenerationPrompt);
        circuitText = newCircuit;
        
        appendMessage('AI', 'Circuit regenerated successfully!', 'success');
        appendMessage('System', 'Loading regenerated circuit into simulator...', 'info');
        
        importCircuit(circuitText);
        startSimulation();
        
      } catch (error) {
        appendMessage('AI', `Error regenerating circuit: ${error.message}`, 'error');
      }
    }

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const userMessage = input.value;
      lastUserRequest = userMessage; // Store the original request
      appendMessage('You', userMessage);
      input.value = '';
      
      updateButtonStates(); // Update button states

      try {
        const prompt = `Current Circuit:\n${circuitText}\n\nUser Request: ${userMessage}\n\nGenerate EXACTLY what the user asks for. If they ask for an LED circuit, include an LED component. If they ask for a 9V battery, use 9V. Be precise and complete.`;
        appendMessage('AI', 'Generating circuit...', 'info');
        
        const newCircuit = await sendToChatGPT(prompt);
        circuitText = newCircuit;
        
        appendMessage('AI', 'Circuit generated successfully!', 'success');
        appendMessage('System', 'Loading circuit into simulator...', 'info');
        
        importCircuit(circuitText);
        startSimulation();

        // Wait a bit then try to get simulation results
        setTimeout(async () => {
          try {
            // Try enhanced simulation data export
            const exportResults = await exportSimulationData();
            if (exportResults.error) {
              // Fallback to original method
              const results = await captureResults();
              appendMessage('Simulation', `Results: ${JSON.stringify(results)}`);
            } else {
              // Enhanced simulation analysis
              lastExportedData = exportResults; // Store the exported data
              
              updateButtonStates(); // Update button states after export
              
              const { simulationData, issues, suggestions } = exportResults;
              
              if (issues && (issues.errors.length > 0 || issues.warnings.length > 0)) {
                appendMessage('Simulation Analysis', `Found ${issues.errors.length} errors and ${issues.warnings.length} warnings`, 'error');
                
                issues.errors.forEach(error => {
                  appendMessage('Error', `${error.message}`, 'error');
                });
                
                issues.warnings.forEach(warning => {
                  appendMessage('Warning', `${warning.message}`, 'info');
                });
                
                if (suggestions && suggestions.length > 0) {
                  appendMessage('Suggestions', `Generated ${suggestions.length} correction suggestions`, 'info');
                  suggestions.forEach(suggestion => {
                    appendMessage('Suggestion', `${suggestion.description}`, 'info');
                  });
                }
              } else {
                appendMessage('Simulation Analysis', 'Circuit simulation running normally', 'success');
              }
              
              // Start monitoring for future issues
              startSimulationMonitoring();
            }
          } catch (error) {
            appendMessage('Simulation', `Simulation ready - click RUN button in CircuitJS to start`);
          }
        }, 3000);
        
      } catch (error) {
        appendMessage('AI', `Error: ${error.message}`, 'error');
      }
    });

    // CircuitJS injection listener
    window.addEventListener("message", (event) => {
      if (event.data.type === "requestCircuit") {
        event.source.postMessage({ type: "circuitResponse", circuit: circuitText }, '*');
      }
    });

    // Export button handler
    document.getElementById('export-btn').addEventListener('click', async () => {
      appendMessage('Export', 'Exporting simulation data...', 'info');
      
      try {
        const exportResults = await exportSimulationData();
        if (exportResults.error) {
          appendMessage('Export', `Error: ${exportResults.error}`, 'error');
        } else {
          lastExportedData = exportResults; // Store the exported data
          const { simulationData, issues, suggestions } = exportResults;
          
          // Create downloadable JSON file
          const dataStr = JSON.stringify({
            timestamp: new Date().toISOString(),
            circuitText: circuitText,
            simulationData: simulationData,
            issues: issues,
            suggestions: suggestions
          }, null, 2);
          
          const dataBlob = new Blob([dataStr], { type: 'application/json' });
          const url = URL.createObjectURL(dataBlob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `circuit-simulation-data-${Date.now()}.json`;
          link.click();
          URL.revokeObjectURL(url);
          
          appendMessage('Export', 'Simulation data exported successfully!', 'success');
        }
      } catch (error) {
        appendMessage('Export', `Export failed: ${error.message}`, 'error');
      }
    });

    // Regenerate button handler
    document.getElementById('regenerate-btn').addEventListener('click', async () => {
      await regenerateWithSimulationContext();
    });

    // Check API key on load
    window.addEventListener('load', () => {
      if (CONFIG.OPENAI_API_KEY === 'YOUR_OPENAI_API_KEY') {
        appendMessage('System', 'Please set your OpenAI API key in config.js', 'error');
      } else {
        appendMessage('System', 'Ready to build circuits!', 'success');
        appendMessage('System', 'Try: "Create a simple LED circuit with a 9V battery and 220 ohm resistor"', 'info');
      }
      
      updateButtonStates(); // Set initial button states
    });
  </script>
</body>
</html> 